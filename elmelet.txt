1. AF_INET:
Csal√°d t√≠pus ‚Äî IPv4-es c√≠meket haszn√°l (host + port).
IPv6 eset√©n AF_INET6.

2. recv():
A kliens vagy szerver fogad adatot a m√°sik f√©lt≈ël. Akkor haszn√°lod, amikor adat √©rkezik a socketen.

3. socket():
L√©trehoz egy √∫j socketet (kommunik√°ci√≥s v√©gpontot).
Pl.: socket.socket(AF_INET, SOCK_STREAM) ‚Üí TCP socket.

4. SOCK_STREAM vs SOCK_DGRAM:

SOCK_STREAM: TCP, megb√≠zhat√≥, sorrendben, kapcsolat alap√∫.

SOCK_DGRAM: UDP, gyors, kapcsolat n√©lk√ºli, csomag alap√∫.

5. bind():
A socketet hozz√°rendeli egy IP-c√≠mhez √©s porthoz (szerver oldalon k√∂telez≈ë).

6. listen():
Szerver TCP socketet v√°rakoz√°si √°llapotba √°ll√≠t, hogy elfogadhasson klienseket.

7. accept():
Elfogad egy √∫j bej√∂v≈ë kapcsolatot, √©s √∫j socketet ad vissza a klienssel val√≥ kommunik√°ci√≥hoz.

8. connect():
Kliens oldalon a kapcsolat l√©trehoz√°sa a szerverrel.

‚öôÔ∏è Adatk√ºld√©s/fogad√°s

9. sendall() el≈ënye:
Automatikusan √∫jrak√ºldi, am√≠g az √∂sszes adat el nem megy.
send() lehet, hogy csak r√©szleges adatot k√ºld.

10. Socket timeout:
Az id≈ëkorl√°t ‚Äî ha egy m≈±velet (pl. recv) nem fejez≈ëdik be adott id≈ën bel√ºl, kiv√©telt dob.

11. settimeout():
Be√°ll√≠tja a socket timeout √©rt√©k√©t m√°sodpercben.

12. recv() 0 byte:
A m√°sik f√©l bez√°rta a kapcsolatot.

13. close():
Lez√°rja a socketet √©s felszabad√≠tja az er≈ëforr√°sokat.

üåê H√°l√≥zati alapok

14. localhost:
A helyi g√©p c√≠me (127.0.0.1).

15. Port sz√°m:
Egy g√©pen bel√ºl azonos√≠tja, melyik alkalmaz√°shoz megy a kapcsolat.

16. IP c√≠m:
A h√°l√≥zaton azonos√≠tja a g√©pet.

17. Kliens-szerver architekt√∫ra:
A kliens k√©r, a szerver v√°laszol.

üîí Socket m≈±k√∂d√©s

18. "Blocking" m≈±velet:
A program v√°rakozik, am√≠g a m≈±velet be nem fejez≈ëdik (pl. recv() v√°r adatot).

19. TCP socket l√©trehoz√°sa:

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)


20. TCP szerver sorrendje:
socket() ‚Üí bind() ‚Üí listen() ‚Üí accept() ‚Üí recv()/send() ‚Üí close()

21. TCP kliens sorrendje:
socket() ‚Üí connect() ‚Üí send()/recv() ‚Üí close()

‚ö° Halad√≥bb be√°ll√≠t√°sok

22. SO_REUSEADDR:
Engedi, hogy √∫jrahaszn√°ld ugyanazt a portot, ha el≈ëz≈ëleg bez√°rtad.

23. Be√°ll√≠t√°sa:

s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)


24. listen(1):
Egyszerre max. 1 v√°rakoz√≥ kapcsolatot enged.

üìÅ Adatok, f√°jlok

25. Bin√°ris adatk√ºld√©s TCP-n:
sendall(binary_data) ‚Äî ne k√≥dold, bin√°ris m√≥don nyisd meg a f√°jlt.

26. struct modul szerepe:
Bin√°ris adatok √∂sszecsomagol√°sa (C-szer≈± form√°tumba) √©s kibont√°sa h√°l√≥zaton.

27. T√∂bb kliens kezel√©se:
select(), poll(), asyncio, vagy threading.

28. with statement el≈ënye:
Automatikusan bez√°rja a socketet, m√©g hiba eset√©n is.

29. Hat√©kony f√°jlk√ºld√©s TCP-n:
Olvasd chunkokra (pl. 4096 byte) √©s sendall()-lal k√ºldd, m√≠g v√©ge.

üì¶ struct modul

30. struct.pack():
Python adatokat bin√°riss√° alak√≠t k√ºld√©shez.

31. struct.unpack():
Bin√°ris adatot Python v√°ltoz√≥kk√° bont.

32. 'f f 1s' form√°tum:
K√©t float √©s egy 1 byte-os string.

33. R√©szleges adatk√ºld√©s kezel√©se:
sendall()-t haszn√°lj vagy ciklusban k√ºldd el az √∂sszes byte-ot.

üîÅ Kapcsolatkezel√©s

34. accept() ut√°n:
√öj socketet kapsz (klienssel val√≥ kommunik√°ci√≥ra) + kliens c√≠met.

35. Kliens kapcsolat lez√°r√°sa:
Kliens socket: client_socket.close(), de a szerver tov√°bb futhat.

36. Server socket vs client socket:

Server socket: v√°r kapcsolatokat (listen, accept)

Client socket: t√©nyleges adatforgalmat kezel (send, recv)

37. F√°jlk√ºld√©s TCP-vel:
Olvas√°s chunkonk√©nt ‚Üí sendall()
Fogad√°s chunkonk√©nt ‚Üí f√°jlba √≠r√°s.

38. ('localhost', 10000):
C√≠m-p√°r, amit bind() √©s connect() is haszn√°l (IP + port).

üß© UDP

39. UDP socket l√©trehoz√°sa:

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)


40. TCP vs UDP:
TCP = megb√≠zhat√≥, kapcsolat alap√∫.
UDP = gyors, de nincs visszaigazol√°s, nincs kapcsolat.

41. sendto():
UDP-n√©l adatot k√ºld egy adott c√≠mre.

42. recvfrom():
Adatot fogad √©s visszaadja az adatot + k√ºld≈ë c√≠m√©t.

43. connect() UDP kliensn√©l:
Nem k√∂telez≈ë (de lehet haszn√°lni).

44. listen() UDP szervern√©l:
Nem l√©tezik, UDP kapcsolat n√©lk√ºli.

45. UDP szerver sorrendje:
socket() ‚Üí bind() ‚Üí recvfrom() ‚Üí sendto() ‚Üí close()

46. UDP kliens sorrendje:
socket() ‚Üí sendto() ‚Üí recvfrom() ‚Üí close()

47. recvfrom() visszat√©r:
Tupple: (data, (ip, port))

48. sendto() param√©terei:
sendto(data, (ip, port))

49. UDP maxim√°lis csomagm√©ret:
Elm√©letben 65,507 byte (gyakorlatban kevesebb, pl. 1500 MTU).

50. Ha UDP csomag elv√©sz:
Nem ker√ºl √∫jrak√ºld√©sre ‚Äî elveszett.

51. Timeout UDP-n√©l:
V√©d a v√©gtelen v√°rakoz√°st√≥l, ha nem j√∂n v√°lasz.

52. bind() UDP kliensn√©l:
Nem k√∂telez≈ë (rendszer automatikusan ad portot).

53. "I I 1s" form√°tum:
K√©t unsigned int √©s egy 1 byte-os string.

54. Timeout kiv√©tel kezel√©se:
try/except socket.timeout: blokkban.

55. TCP vs UDP f√°jlk√ºld√©s:
TCP: megb√≠zhat√≥, sorrendhelyes.
UDP: gyorsabb, de csomagveszt√©s lehets√©ges, ez√©rt extra logika kell.

üåç Proxy, select

56. Proxy szerver:
Kliens √©s c√©l szerver k√∂z√∂tti k√∂zvet√≠t≈ë, tov√°bb√≠tja vagy sz≈±ri a k√©r√©seket.

57. select():
Figyel t√∂bb socketet egyszerre, hogy melyik olvashat√≥/√≠rhat√≥.

58. select() visszat√©r:
H√°rom lista: (olvashat√≥, √≠rhat√≥, hib√°s socketek).

59. HTTP sz≈±r√©s proxy-ban:
A recv()-elt HTTP k√©r√©seket elemzed (pl. GET /path HTTP/1.1), √©s enged√©lyezed/tiltod.

60. 404:
HTTP st√°tuszk√≥d ‚Äì ‚ÄûNem tal√°lhat√≥‚Äù (a k√©rt er≈ëforr√°s nem l√©tezik).

61. Ha select() timeout-ol:
√úres list√°kkal t√©r vissza.

62. socket.timeout kiv√©tel:
Akkor dob√≥dik, ha egy blokkol√≥ m≈±velet t√∫ll√©pi az id≈ëkorl√°tot.

63. Kapcsolat megszakad√°s detekt√°l√°sa TCP-ben:
recv() 0 byte-ot ad vissza, vagy kiv√©tel (ConnectionResetError).

64. bind() sikertelens√©g leggyakoribb oka:
A port m√°r foglalt vagy nincs jogosults√°g (pl. <1024 port root n√©lk√ºl).
